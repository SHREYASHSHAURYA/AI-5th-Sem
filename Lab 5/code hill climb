import random

def print_board(board):
    n = len(board)
    for i in range(n):
        row = ['.'] * n
        row[board[i]] = 'Q'
        print(' '.join(row))
    print()

def random_board(n):
    # Each queen placed randomly in a column
    return [random.randint(0, n-1) for _ in range(n)]

def heuristic(board):
    # Count attacking pairs
    attacks = 0
    n = len(board)
    for i in range(n):
        for j in range(i+1, n):
            if board[i] == board[j] or abs(board[i]-board[j]) == abs(i-j):
                attacks += 1
    return attacks

def get_neighbors(board):
    n = len(board)
    neighbors = []
    for row in range(n):
        for col in range(n):
            if col != board[row]:
                neighbor = board.copy()
                neighbor[row] = col
                neighbors.append(neighbor)
    return neighbors

def hill_climbing_demo(n=4, max_moves=5):
    current = random_board(n)
    current_h = heuristic(current)
    
    print("Initial Board:")
    print_board(current)
    print(f"Heuristic: {current_h}\n")
    
    for move in range(max_moves):
        neighbors = get_neighbors(current)
        # sort neighbors by heuristic (ascending, better first)
        neighbors.sort(key=heuristic)
        
        # Instead of always taking the best, randomly pick one of the top few
        # This prevents jumping straight to a solved state
        top_choices = neighbors[:min(3, len(neighbors))]
        next_board = random.choice(top_choices)
        next_h = heuristic(next_board)
        
        if next_h >= current_h:
            print(f"Move {move+1}: No better neighbor found, stopping.\n")
            break
        
        current, current_h = next_board, next_h
        
        print(f"Move {move+1}:")
        print_board(current)
        print(f"Heuristic: {current_h}\n")
    
    print("Final Board after limited moves:")
    print_board(current)
    print(f"Final Heuristic: {current_h}")

# Run the demo
hill_climbing_demo(4, max_moves=5)
